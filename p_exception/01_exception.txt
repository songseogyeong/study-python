예외 처리
    프로그램 실행 중 오류 발생 시 강제 종료되기 때문에 이를 막기 위하여 예외 처리를 작성한다.
    제어문으로 오류를 막을 수 없는 상황에서는 반드시 예외처리를 작성해야 한다.

    게임 접속자가 많아서 튕기는 건 네트워크 문제,
    게임 할 때 특정행동하면 튕기는 건 예외처리를 제대로 못 한 거라고 볼 수 있음
    (if문으로 쓰면 오류에 대한 경우의 수를 다 써야하기 때문에 예외처리 사용)

try, except문

    1번 방법.
    try에 오류가 생길 거 같은 문장 작성
    except에서 오류 문장 처리

    try:
        오류가 발생할 수 있는 문장

    * 오류 객체
    except 발생 오류(=class) as 오류객체(=class를 객체화)
        오류 발생 시 실행할 문장

    ...

    2번 방법.
    try:
        오류가 발생할 수 있는 문장

    * 자동으로 객체에 오류가 담김
    해결할 오류가 아닐 때 사용
    except 발생 오류:
        오류 발생 시 실행할 문장

    ...

    3번 방법.
        * else 같은 느낌 모든 애들이 여기 들어오라는 뜻
    클래스는 부모가 있음 모든 오류 클래스가 동일한 규모를 상속받음
    모든 자식은 부모 타입이다.
    에러난 부모 타입을 검사하면 모든 오류를 잡아낼 수 있음
    try:
        오류가 발생할 수 있는 문장

    except:
        오류 발생 시 실행할 문장

    ...

    * 파이널리는 위에서 try문에 있는 오류 발생 시
    익셉트로 들어감 근데 익셉트에 잡는 코드가 없으면 파이널리로 옴
    에러나 나도 실행 이러게 안 나도 실행
    모든 상황에서 뜸
    트라이문에 있는 코드가 뭔가 열었을 때(메모리 할당) 오류가 발생하던말던 닫아줘야하는데(메모리 해제)
    =안 닫으면 메모리 누수가 생김(컴퓨터 느려짐)
    그래서 막으려고 파이널리 사용
    finally:
        오류 발생 여부와 상관 없이 실행


예외 발생시키기
    심각한 문제가 발생하기 전에 일부러 프로그램을 강제 종료할 때 사용한다
    * 게임 사용자가 핵을 쓰면 튕기게 하기

    * 하지만 위 경우는 흔하지 않기 때문에, 아래 목적으로쓰는 경우가 많다.
    예외를 한 곳에 묶어서 처리하기 위해 사용한다(상위 과정에서 다룰 예정)

    raise 발생 오류


예외 만들기
    * 모든 오류의 부모는 Exception이라는 class라 우리는 우리의 오류명으로 자식 클래스를 만들고 문자열로 재정의함
    class 오류명(Exception):
        def __str__(self):
            return "오류 메세지"

